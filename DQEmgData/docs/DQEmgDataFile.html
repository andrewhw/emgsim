<html><head><title>DQEmgDataFile Library</title></head>
<body><h1>
<img src=coclogo.gif>
<a name="topofdoc">Library DQEmgDataFile</a></h1>
<hr><p></p></a>
<p><strong>[
<a href="/keyweb.html">Keywords</a> | 
<a href="#classes">Classes</a> | 
<a href="#data">Data</a> | 
<a href="#functions">Functions</a>
 ]</strong><p>
<h2>Quick Index</h2>
<dl>
</dl>
<p><br><p><a name="classes"><hr><p></p></a><h2>Classes</h2>
<dl><dl>
    <a href="FileFormatProposal.txt">FileFormatProposal</a>
    text file.
<dt><a href="DQEmgChannelData.html" target=_top>DQEmgChannelData</a>
<dd>
    Channel Data -- this is the data recorded on a
    given channel during a single contraction.  The
    intention is that all channels recorded simultaneously
    will reside in the same data file.
    <p>
    For example, if an experiment is set up with an 
    indwelling electrode for EMG, plus a surface electrode
    and a force transducer all recording at the same time,
    the resulting file would have three channels, each
    one containing the data from one device.  The channel
    description and units will identify the device stored
    in each channel.
    <p>
    The fields stored in the Channel Data structure are:
        <ul>

        <li>
        Channel Number
            <ul>
            <li>
            A small integer number indicating the channel
            on the physical recording equipment.
            </li>
            </ul>
        </li>

        <li>
        Channel Description
            <ul>
            <li>
            An optional textual field indicating any parameters
            which may need to be recorded on a channel by
            channel basis.  The primary purpose of this field
            will be to identify the source of the data stored
            in this channel structure.
            </li>
            </ul>
        </li>

        <li>
        High-Pass Cutoff (µHz)
            <ul>
            <li>
            The high-pass cutoff frequency of the filtering
            performed before storage.  These values are stored
            in µHz in order to avoid problems with the storage
            of fractional numbers.
            </li>
            </ul>
        </li>

        <li>
        Low-Pass Cutoff (µHz)
            <ul>
            <li>
            The low-pass cutoff frequency of the filtering
            performed before storage.
            </li>
            </ul>
        </li>

        <li>
        Sampling Rate
            <ul>
            <li>
            The rate, in Hz, at which the data was sampled.
            </li>
            </ul>
        </li>

        <li>
        Number of Samples
            <ul>
            <li>
            This is the length of the data vector.
            </li>
            </ul>
        </li>

        <li>
        Elapsed Time
            <ul>
            <li>
            Optional -- this will indicate the time elapsed
            during the contraction.  This can also be calculated
            by Sampling Rate * Number of Samples.
            </li>
            </ul>
        </li>

        <li>
        Units
            <ul>
            <li>
            This field will describe the units in which the
            data is encoded, as divided by the scale.
            <p>
            The intention is that the Units field is chosen
            as a metric unit string describing the storage
            units.  Examples: "mV" - milli Volts.  "C" degrees
            Centigrade, <i>etc</i>.
            </li>
            </ul>
        </li>

        <li>
        Scale
            <ul>
            <li>
            The <i>scale</i> is used in conjunction with the data
            vector to transform the vector back from an
            integer-based 16 or 32 bit representation into
            a floating-point representation.
            <p>
            In order to reconstruct the vector in the specified
            units, the scale will be multiplied by the value
            in the data vector.
            </li>
            </ul>
        </li>
        
        <li>
        Evoked Values
            <ul>
            <li>
            The <i>Evoked Values</i> are generated by the AcquireEmg or MPS
            Evoked window and contain the : <br>
             o peakToPeakArea, <br>
             o peakToPeakAmplitude and <br>
             o negativePeakAmplitude <br>
            values. They are loaded if the contraction type
            of the data file was detected to be EVOKED. 
            </li>
            </ul>
        </li>
        
        <li>
        Data
            <ul>
            <li>
            The data is a vector of 16 or 32 bit values.  The
            internal storage is defined by the setting of the
            encoding argument.
            <p>
            The data, when multiplied by the scale, will
            provide a vector of floating-point number in the
            units indicated in the units string.
            <p>
            This vector will be of the length indicated by 
            the number of samples argument.
            </li>
            </ul>
        </li>

        <li>
        Data Encoding
            <ul>
            <li>
            Used internally to expand the file storage values
            from 16 to 32 bit storage.  Setting the encoding
            to 32-bit (4 byte) will double the file storage
            size requirements.
            </li>
            </ul>
        </li>

        </ul>
<dt><a href="DQEmgData.html" target=_top>DQEmgData</a>
<dd>
    An entire contraction data set.  A contraction
    is made up of a global definition and a set
    of channel data structures.  Each channel data
    structure will store the values recorded by a
    given instrument (EMG, temperature, force, etc).

    <p>
    A contraction is the set of all of the channels
    recorded at the same time, plus the following
    information in the header to make the data
    useful for study purposes:
        <ul>
        <li>
        Operator/Physician
            <ul>
            <li>
            This is the operator of the EMG collection
            equipment.  The operator field should be
            filled in a standard way to allow other
            contractions and studies by the same operator
            to be identified.
            </li>
            </ul>
        </li>
        <li>
        Patient
            <ul>
            <li>
            This will be a unique identifier for the
            patient.  Note that this is a freeform text
            field, so any identification number as well
            as, or instead of, the patient name may be
            included here.
            </li>
            </ul>
        </li>
        <li>
        Muscle
            <ul>
            <li>
            This is the muscle identification from which
            the contraction was recorded.  Laterality
            will identify the side of the body, allowing
            the identification of the particular muscle
            on the patient.
            </li>
            </ul>
        </li>
        <li>
        Muscle Side
            <ul>
            <li>
            This is the muscle laterality.
            </li>
            </ul>
        </li>
        
        <li>
        Contraction Type
            <ul>
            <li>
            AcquireEmg stores the contraction type of the 
            signal. The voluntary signal can be one 
            of the three following types: <br>
                o MVC   <br>
                o Spontaneous Activity <br>
                o Sub-Maximal   <br>
            Whereas the evoke signal has the type
            o Evoke.
            </li>
            </ul>
        </li>
    
        <li>
        General textual note information
            <ul>
            <li>
            This field is intended for the storage
            of any general textual information the physician
            wishes to attach to this contraction.
            <p>
            Note that this field may be further delimited
            by the user software in order to include any
            notational attributes which may be available
            in the program.
            </li>
            </ul>
        </li>
        <li>
        Vendor of recording equipment/software
            <ul>
            <li>
            This field is intended to allow the identification
            of the company and particular software platform
            which created the file.  This will primarily
            be of use when doing historical studies, where
            the particular platform may become a relevant
            factor.
            </li>
            </ul>
        </li>
        <li>
        Date & Time of the contraction
            <ul>
            <li>
            Date & time of the study, stored in seconds
            since the epoch of Jan 1, 1970, UTC.
            </li>
            </ul>
        </li>
        <li>
        `New' Flags
            <ul>
            <li>
            There are three `new' flags which can be set,
            to force the contraction to belong to a new
            muscle, patient or study.
            <p>
            These are useful when the file format is used
            as part of a data stream between an acquisition
            program &amp; patient database and the QEMG
            system.  The flags are used to indicate when
            a new data set is being introduced, when this
            information may not be apparant from inspection
            of the other data fields.  For instance, if the
            physician wishes to start a new study of the
            bicep muscle, this flag may be set for the
            first contraction, in order that this data not
            be collected with data from existing bicep contractions
            for the same patient.
            </li>
            </ul>
        </li>
        </ul>

    <p>
    The file format is described in the
    <a href="FileFormatProposal.txt">FileFormatProposal</a>
    text file.
</dl></dl>
<p>Back to the <a href="#topofdoc">top</a> of  <i>DQEmgDataFile</i><p>
<a name="data"><hr><p></p></a><h2>Data</h2>
<dl>
</dl>
<p>Back to the <a href="#topofdoc">top</a> of  <i>DQEmgDataFile</i><p>
<a name="functions"><hr><p></p></a><h2>Global Functions</h2>
<dl>
<dd>int <a href="DQEmgDataFile.html#int_isLeapYear(int_year)$"><font color=green>dqIsLeapYear</font></a>(int year);
<dd>int <a href="DQEmgDataFile.html#int_isDayInMonth(int_year,_int_month,_int_day)$"><font color=green>dqIsDayInMonth</font></a>(int year, int month, int day);
<dd>long <a href="DQEmgDataFile.html#long_getYearFromJulianDate(long_julianDate)$"><font color=green>dqGetYearFromJulianDate</font></a>(long julianDate);
<dd>unsigned long <a href="DQEmgDataFile.html#unsigned_long_sGetMonthFromJulianDate(long_julianDate)$"><font color=green>dqSGetMonthFromJulianDate</font></a>(long julianDate);
<dd>unsigned long <a href="DQEmgDataFile.html#unsigned_long_getDayFromJulianDate(long_julianDate)$"><font color=green>dqGetDayFromJulianDate</font></a>(long julianDate);
<dd>int <a href="DQEmgDataFile.html#int_isGregorianDateValid(_long_year,_unsigned_long_month,_unsigned_long_day_)$"><font color=green>dqIsGregorianDateValid</font></a>( long year, unsigned long month, unsigned long day );
<dd>int <a href="DQEmgDataFile.html#int_getJulianDate(long_*julianDate,_int_year,_int_month,_int_day)$"><font color=green>dqGetJulianDate</font></a>(long *julianDate, int year, int month, int day);
<dd>int <a href="DQEmgDataFile.html#int_getGregorianDate(_unsigned_long*_year,_unsigned_long*_month,_unsigned_long*_day,_long_julianDate_)$"><font color=green>dqGetGregorianDate</font></a>( unsigned long* year, unsigned long* month, unsigned long* day, long julianDate );
</dl>
<p>Back to the <a href="#topofdoc">top</a> of  <i>DQEmgDataFile</i><p>
<a name="int_isLeapYear(int_year)$"><hr><p></p><h3>int isLeapYear(int year);</h3></a>
<strong>#include "<a href="dqemgjulian.h">dqemgjulian.h</a>"</strong><p>
       Is the given year a leap year?
<p><pre>
    int <a href="#int_isLeapYear(int_year)$">isLeapYear</a>(int year);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgDataFile </i> <p>
<a name="int_isDayInMonth(int_year,_int_month,_int_day)$"><hr><p></p><h3>int dqIsDayInMonth(int year, int month, int day);</h3></a>
<strong>#include "<a href="dqemgjulian.h">dqemgjulian.h</a>"</strong><p>
       Is the given day/month/year combo
       valid for the given (possibly leap)
       year?
<p><pre>
    int <a href="#int_isDayInMonth(int_year,_int_month,_int_day)$">dqIsDayInMonth</a>(int year, int month, int day);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgDataFile </i> <p>
<a name="long_getYearFromJulianDate(long_julianDate)$"><hr><p></p><h3>long dqGetYearFromJulianDate(long julianDate);</h3></a>
<strong>#include "<a href="dqemgjulian.h">dqemgjulian.h</a>"</strong><p>
       Return the year portion of a Julian date
<p><pre>
    long <a href="#long_getYearFromJulianDate(long_julianDate)$">dqGetYearFromJulianDate</a>(long julianDate);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgDataFile </i> <p>
<a name="unsigned_long_sGetMonthFromJulianDate(long_julianDate)$"><hr><p></p><h3>unsigned long dqSGetMonthFromJulianDate(long julianDate);</h3></a>
<strong>#include "<a href="dqemgjulian.h">dqemgjulian.h</a>"</strong><p>
       Return the month portion of a Julian date
<p><pre>
    unsigned long <a href="#unsigned_long_sGetMonthFromJulianDate(long_julianDate)$">dqSGetMonthFromJulianDate</a>(long julianDate);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgDataFile </i> <p>
<a name="unsigned_long_getDayFromJulianDate(long_julianDate)$"><hr><p></p><h3>unsigned long dqGetDayFromJulianDate(long julianDate);</h3></a>
<strong>#include "<a href="dqemgjulian.h">dqemgjulian.h</a>"</strong><p>
       Return the day portion of a Julian date
<p><pre>
    unsigned long <a href="#unsigned_long_getDayFromJulianDate(long_julianDate)$">dqGetDayFromJulianDate</a>(long julianDate);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgDataFile </i> <p>
<a name="int_isGregorianDateValid(_long_year,_unsigned_long_month,_unsigned_long_day_)$"><hr><p></p><h3>int dqIsGregorianDateValid( long year, unsigned long month, unsigned long day );</h3></a>
<strong>#include "<a href="dqemgjulian.h">dqemgjulian.h</a>"</strong><p>
       Is the Gregorian date a valid date?
<p><pre>
    int <a href="#int_isGregorianDateValid(_long_year,_unsigned_long_month,_unsigned_long_day_)$">dqIsGregorianDateValid</a>(
                long year,
                unsigned long month,
                unsigned long day
            );
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgDataFile </i> <p>
<a name="int_getJulianDate(long_*julianDate,_int_year,_int_month,_int_day)$"><hr><p></p><h3>int dqGetJulianDate(long *julianDate, int year, int month, int day);</h3></a>
<strong>#include "<a href="dqemgjulian.h">dqemgjulian.h</a>"</strong><p>
       Convert Gregorian calendar date to the corresponding Julian day
       number j.
<p>
       From 199 from Communications of the ACM, Volume 6, No. 8,
       (Aug. 1963), p. 444.
<p>
       Gregorian calendar started on Sep. 14, 1752; this function
       not valid before that.
<p>
<p><pre>
    int <a href="#int_getJulianDate(long_*julianDate,_int_year,_int_month,_int_day)$">dqGetJulianDate</a>(long *julianDate, int year, int month, int day);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgDataFile </i> <p>
<a name="int_getGregorianDate(_unsigned_long*_year,_unsigned_long*_month,_unsigned_long*_day,_long_julianDate_)$"><hr><p></p><h3>int dqGetGregorianDate( unsigned long* year, unsigned long* month, unsigned long* day, long julianDate );</h3></a>
<strong>#include "<a href="dqemgjulian.h">dqemgjulian.h</a>"</strong><p>
       Convert a Julian day number to its corresponding Gregorian
       calendar date.
<p>
       Algorithm 199 from Communications of the ACM, Volume 6, No. 8,
       (Aug. 1963), p. 444.
<p>
       Gregorian calendar started on Sep. 14, 1752; this function not
       valid for dates before that.  
<p>
<p><pre>
    int <a href="#int_getGregorianDate(_unsigned_long*_year,_unsigned_long*_month,_unsigned_long*_day,_long_julianDate_)$">dqGetGregorianDate</a>(
                unsigned long* year,
                unsigned long* month,
                unsigned long* day,
                long julianDate
            );
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgDataFile </i> <p>
<hr><p></p>
Generated from source by the <i><a href="http://www.stratasys.com/software/cocoon/index.htm">Cocoon</a></i> utilities on Thu Jan 15 07:27:46 2004
.<p>
<address>Report <a href="mailto:jkotula@vitalimages.com">problems</a> to jkotula@vitalimages.com</address>
