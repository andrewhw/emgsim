<html><head><title>DQEmgChannelData Documentation</title></head>
<body><h1>
<a name="topofdoc"><img src=coclogo.gif>DQEmgChannelData</a></h1>
<dl>
<dd>
    Channel Data -- this is the data recorded on a
    given channel during a single contraction.  The
    intention is that all channels recorded simultaneously
    will reside in the same data file.
    <p>
    For example, if an experiment is set up with an 
    indwelling electrode for EMG, plus a surface electrode
    and a force transducer all recording at the same time,
    the resulting file would have three channels, each
    one containing the data from one device.  The channel
    description and units will identify the device stored
    in each channel.
    <p>
    The fields stored in the Channel Data structure are:
        <ul>

        <li>
        Channel Number
            <ul>
            <li>
            A small integer number indicating the channel
            on the physical recording equipment.
            </li>
            </ul>
        </li>

        <li>
        Channel Description
            <ul>
            <li>
            An optional textual field indicating any parameters
            which may need to be recorded on a channel by
            channel basis.  The primary purpose of this field
            will be to identify the source of the data stored
            in this channel structure.
            </li>
            </ul>
        </li>

        <li>
        High-Pass Cutoff (µHz)
            <ul>
            <li>
            The high-pass cutoff frequency of the filtering
            performed before storage.  These values are stored
            in µHz in order to avoid problems with the storage
            of fractional numbers.
            </li>
            </ul>
        </li>

        <li>
        Low-Pass Cutoff (µHz)
            <ul>
            <li>
            The low-pass cutoff frequency of the filtering
            performed before storage.
            </li>
            </ul>
        </li>

        <li>
        Sampling Rate
            <ul>
            <li>
            The rate, in Hz, at which the data was sampled.
            </li>
            </ul>
        </li>

        <li>
        Number of Samples
            <ul>
            <li>
            This is the length of the data vector.
            </li>
            </ul>
        </li>

        <li>
        Elapsed Time
            <ul>
            <li>
            Optional -- this will indicate the time elapsed
            during the contraction.  This can also be calculated
            by Sampling Rate * Number of Samples.
            </li>
            </ul>
        </li>

        <li>
        Units
            <ul>
            <li>
            This field will describe the units in which the
            data is encoded, as divided by the scale.
            <p>
            The intention is that the Units field is chosen
            as a metric unit string describing the storage
            units.  Examples: "mV" - milli Volts.  "C" degrees
            Centigrade, <i>etc</i>.
            </li>
            </ul>
        </li>

        <li>
        Scale
            <ul>
            <li>
            The <i>scale</i> is used in conjunction with the data
            vector to transform the vector back from an
            integer-based 16 or 32 bit representation into
            a floating-point representation.
            <p>
            In order to reconstruct the vector in the specified
            units, the scale will be multiplied by the value
            in the data vector.
            </li>
            </ul>
        </li>
        
        <li>
        Evoked Values
            <ul>
            <li>
            The <i>Evoked Values</i> are generated by the AcquireEmg or MPS
            Evoked window and contain the : <br>
             o peakToPeakArea, <br>
             o peakToPeakAmplitude and <br>
             o negativePeakAmplitude <br>
            values. They are loaded if the contraction type
            of the data file was detected to be EVOKED. 
            </li>
            </ul>
        </li>
        
        <li>
        Data
            <ul>
            <li>
            The data is a vector of 16 or 32 bit values.  The
            internal storage is defined by the setting of the
            encoding argument.
            <p>
            The data, when multiplied by the scale, will
            provide a vector of floating-point number in the
            units indicated in the units string.
            <p>
            This vector will be of the length indicated by 
            the number of samples argument.
            </li>
            </ul>
        </li>

        <li>
        Data Encoding
            <ul>
            <li>
            Used internally to expand the file storage values
            from 16 to 32 bit storage.  Setting the encoding
            to 32-bit (4 byte) will double the file storage
            size requirements.
            </li>
            </ul>
        </li>

        </ul>
</dl>
<hr><p></p>
<p><strong>[ 
<a href="DQEmgDataFile.html">DQEmgDataFile</a> | 
<a href="DQEmgData.h">Source</a> | 
<a href="/keyweb.html">Keywords</a> | 
<a href="#aag">Summary</a> | <a href="#parents">Ancestors</a> | <a href="#flat">All Members</a> | <a href="#children">Descendants</a>  ]</strong><p>
<h2><a name="quickind">Quick Index</a></h2>
<dl>
</dl>
<a name="aag"><hr><p></p></a><h2>Class Summary</h2>
class OS_EXPORT DQEmgChannelData

<br>{
<br><i><b>public</b></i>:
<dl>
<dd><a href="DQEmgChannelData.html#DQEmgChannelData()$"><font color=green>DQEmgChannelData</font></a>();
<dd><a href="DQEmgChannelData.html#DQEmgChannelData(_unsigned_char_channelNumber,_unsigned_long_highPassCutoff,_unsigned_long_lowPassCutoff,_const_char_*channelDescription_)$"><font color=green>DQEmgChannelData</font></a>( unsigned char channelNumber, unsigned long highPassCutoff, unsigned long lowPassCutoff, const char *channelDescription );
<dd>~<a href="DQEmgChannelData.html#~DQEmgChannelData()$"><font color=green>DQEmgChannelData</font></a>();
<dd>int <a href="DQEmgChannelData.html#int_setData(_unsigned_long_numSamples,_float_*data,_unsigned_long_samplingRate,_const_char_*unitDescription,_int_encodingWidth_,_long_maxUnscaledValue_)$"><font color=green>setData</font></a>( unsigned long numSamples, float *data, unsigned long samplingRate, const char *unitDescription, int encodingWidth , long maxUnscaledValue );
<dd>int <a href="DQEmgChannelData.html#int_setData(_unsigned_long_numSamples,_short_*data,_unsigned_long_samplingRate,_const_char_*unitDescription,_float_scale_)$"><font color=green>setData</font></a>( unsigned long numSamples, short *data, unsigned long samplingRate, const char *unitDescription, float scale );
<dd>int <a href="DQEmgChannelData.html#int_setData(_unsigned_long_numSamples,_long_*data,_unsigned_long_samplingRate,_const_char_*unitDescription,_float_scale_)$"><font color=green>setData</font></a>( unsigned long numSamples, long *data, unsigned long samplingRate, const char *unitDescription, float scale );
<dd>enum <a href="DQEmgChannelData.html#enum_Encoding_$"><font color=green>Encoding</font></a> ;
<dd>int <a href="DQEmgChannelData.html#int_setEncoding(Encoding_encoding)$"><font color=green>setEncoding</font></a>(Encoding encoding);
<dd>int <a href="DQEmgChannelData.html#int_getEncodingFlags()_const$"><font color=green>getEncodingFlags</font></a>() const;
<dd>int <a href="DQEmgChannelData.html#int_getEncodingWidth()_const$"><font color=green>getEncodingWidth</font></a>() const;
<dd>short *<a href="DQEmgChannelData.html#short_*getDataAsShort(_unsigned_long_*numSamples,_unsigned_long_*samplingRate,_float_*scale_)$"><font color=green>getDataAsShort</font></a>( unsigned long *numSamples, unsigned long *samplingRate, float *scale );
<dd>long *<a href="DQEmgChannelData.html#long_*getDataAsLong(_unsigned_long_*numSamples,_unsigned_long_*samplingRate,_float_*scale_)$"><font color=green>getDataAsLong</font></a>( unsigned long *numSamples, unsigned long *samplingRate, float *scale );
<dd>const char *<a href="DQEmgChannelData.html#const_char_*getUnitDescription()_const$"><font color=green>getUnitDescription</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setChannelDescription(const_char_*newDescription)$"><font color=green>setChannelDescription</font></a>(const char *newDescription);
<dd>const char *<a href="DQEmgChannelData.html#const_char_*getChannelDescription()_const$"><font color=green>getChannelDescription</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setChannelNumber(unsigned_char_channelNumber)$"><font color=green>setChannelNumber</font></a>(unsigned char channelNumber);
<dd>unsigned char <a href="DQEmgChannelData.html#unsigned_char_getChannelNumber()_const$"><font color=green>getChannelNumber</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setHighPassCutoff(unsigned_long_frequency)$"><font color=green>setHighPassCutoff</font></a>(unsigned long frequency);
<dd>unsigned long <a href="DQEmgChannelData.html#unsigned_long_getHighPassCutoff()_const$"><font color=green>getHighPassCutoff</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setLowPassCutoff(unsigned_long_frequency)$"><font color=green>setLowPassCutoff</font></a>(unsigned long frequency);
<dd>unsigned long <a href="DQEmgChannelData.html#unsigned_long_getLowPassCutoff()_const$"><font color=green>getLowPassCutoff</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setElapsedTime(unsigned_long_newTime)$"><font color=green>setElapsedTime</font></a>(unsigned long newTime);
<dd>unsigned long <a href="DQEmgChannelData.html#unsigned_long_getElapsedTime()_const$"><font color=green>getElapsedTime</font></a>() const;
<dd>unsigned long <a href="DQEmgChannelData.html#unsigned_long_getNumberOfSamples()_const$"><font color=green>getNumberOfSamples</font></a>() const;
<dd>unsigned long <a href="DQEmgChannelData.html#unsigned_long_getSampleRate()_const$"><font color=green>getSampleRate</font></a>() const;
<dd>float <a href="DQEmgChannelData.html#float_getScaleFactor()_const$"><font color=green>getScaleFactor</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponseOnsetPos(short_onset)$"><font color=green>setEvokedResponseOnsetPos</font></a>(short onset);
<dd>short <a href="DQEmgChannelData.html#short_getEvokedResponseOnsetPos()_const$"><font color=green>getEvokedResponseOnsetPos</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponsePeakOnsetPos(short_peakOnset)$"><font color=green>setEvokedResponsePeakOnsetPos</font></a>(short peakOnset);
<dd>short <a href="DQEmgChannelData.html#short_getEvokedResponsePeakOnsetPos()_const$"><font color=green>getEvokedResponsePeakOnsetPos</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponseNegativePeakPos(short_NegativePeak)$"><font color=green>setEvokedResponseNegativePeakPos</font></a>(short NegativePeak);
<dd>short <a href="DQEmgChannelData.html#short_getEvokedResponseNegativePeakPos()_const$"><font color=green>getEvokedResponseNegativePeakPos</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponsePeakEndPos(short_peakEnd)$"><font color=green>setEvokedResponsePeakEndPos</font></a>(short peakEnd);
<dd>short <a href="DQEmgChannelData.html#short_getEvokedResponsePeakEndPos()_const$"><font color=green>getEvokedResponsePeakEndPos</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponsePositivePeakPos(short_posPeak)$"><font color=green>setEvokedResponsePositivePeakPos</font></a>(short posPeak);
<dd>short <a href="DQEmgChannelData.html#short_getEvokedResponsePositivePeakPos()_const$"><font color=green>getEvokedResponsePositivePeakPos</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponseEndPos(short_End)$"><font color=green>setEvokedResponseEndPos</font></a>(short End);
<dd>short <a href="DQEmgChannelData.html#short_getEvokedResponseEndPos()_const$"><font color=green>getEvokedResponseEndPos</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponsePeakToPeakAmplitude(float_peakToPeakAmplitude)$"><font color=green>setEvokedResponsePeakToPeakAmplitude</font></a>(float peakToPeakAmplitude);
<dd>float <a href="DQEmgChannelData.html#float_getEvokedResponsePeakToPeakAmplitude()_const$"><font color=green>getEvokedResponsePeakToPeakAmplitude</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponseNegativePeakAmplitude(float_negativePeakAmplitude)$"><font color=green>setEvokedResponseNegativePeakAmplitude</font></a>(float negativePeakAmplitude);
<dd>float <a href="DQEmgChannelData.html#float_getEvokedResponseNegativePeakAmplitude()_const$"><font color=green>getEvokedResponseNegativePeakAmplitude</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponseDuration(float_duration)$"><font color=green>setEvokedResponseDuration</font></a>(float duration);
<dd>float <a href="DQEmgChannelData.html#float_getEvokedResponseDuration()_const$"><font color=green>getEvokedResponseDuration</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponseNegativePeakDuration(float_negativePeakDuration)$"><font color=green>setEvokedResponseNegativePeakDuration</font></a>(float negativePeakDuration);
<dd>float <a href="DQEmgChannelData.html#float_getEvokedResponseNegativePeakDuration()_const$"><font color=green>getEvokedResponseNegativePeakDuration</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponseNegativePeakArea(float_negativePeakArea)$"><font color=green>setEvokedResponseNegativePeakArea</font></a>(float negativePeakArea);
<dd>float <a href="DQEmgChannelData.html#float_getEvokedResponseNegativePeakArea()_const$"><font color=green>getEvokedResponseNegativePeakArea</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponseArea(float_area)$"><font color=green>setEvokedResponseArea</font></a>(float area);
<dd>float <a href="DQEmgChannelData.html#float_getEvokedResponseArea()_const$"><font color=green>getEvokedResponseArea</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponseValidity(bool_Valid)$"><font color=green>setEvokedResponseValidity</font></a>(bool Valid);
<dd>bool <a href="DQEmgChannelData.html#bool_getEvokedResponseValidity()_const$"><font color=green>getEvokedResponseValidity</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setNumberOfSmupsInAvg(int_NumSmups)$"><font color=green>setNumberOfSmupsInAvg</font></a>(int NumSmups);
<dd>int <a href="DQEmgChannelData.html#int_getNumberOfSmupsInAvg()_const$"><font color=green>getNumberOfSmupsInAvg</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_dump(FILE_*fp)$"><font color=green>dump</font></a>(FILE *fp);
</dl>
<i><b>protected</b></i>:
<dl>
</dl>
}; // DQEmgChannelData <p>
<p>Back to the <a href="#topofdoc">top</a> of  <i>DQEmgChannelData</i><p>
<a name="DQEmgChannelData()$"><hr><p></p><h3>DQEmgChannelData();</h3></a>
           Create an empty data channel object
<p><pre>
        <a href="#DQEmgChannelData()$">DQEmgChannelData</a>();
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="DQEmgChannelData(_unsigned_char_channelNumber,_unsigned_long_highPassCutoff,_unsigned_long_lowPassCutoff,_const_char_*channelDescription_)$"><hr><p></p><h3>DQEmgChannelData( unsigned char channelNumber, unsigned long highPassCutoff, unsigned long lowPassCutoff, const char *channelDescription );</h3></a>
           Create a data channel object with
           the attached description.  Use
           <a href="#int_setData(_unsigned_long_numSamples,_float_*data,_unsigned_long_samplingRate,_const_char_*unitDescription,_int_encodingWidth_,_long_maxUnscaledValue_)$">setData</a>() to attach an actual data
           stream.
<p><pre>
        <a href="#DQEmgChannelData()$">DQEmgChannelData</a>(
                        unsigned char channelNumber,
                        unsigned long highPassCutoff,
                        unsigned long lowPassCutoff,
                        const char *channelDescription = NULL
                    );
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="~DQEmgChannelData()$"><hr><p></p><h3>~DQEmgChannelData();</h3></a>
           Destroy this channel data object
<p><pre>
        ~DQEmgChannelData();
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="int_setData(_unsigned_long_numSamples,_float_*data,_unsigned_long_samplingRate,_const_char_*unitDescription,_int_encodingWidth_,_long_maxUnscaledValue_)$"><hr><p></p><h3>int setData( unsigned long numSamples, float *data, unsigned long samplingRate, const char *unitDescription, int encodingWidth , long maxUnscaledValue );</h3></a>
           Set the data from a series of float
           values.  The data is stored in the
           file based on the setting of the
           encoding value, which defaults to
           short.  In order to convert to
           the encoding based integral-data width,
           a scale factor is calculated.  This
           scale factor is formed by calculating 
           the number by which the data must
           be divided in order to fit within
           the provided range.  If a smaller
           range than that provided by the
           data encoding width is desired,
           this can be passed in instead.
           <p>
           If the <b>maxUnscaledValue</b>
           is set to zero, the default value
           for the encoding width is used.
           <p>
           Note that the sampling rate is set
           in samples per second
<p><pre>
        int <a href="#int_setData(_unsigned_long_numSamples,_float_*data,_unsigned_long_samplingRate,_const_char_*unitDescription,_int_encodingWidth_,_long_maxUnscaledValue_)$">setData</a>(
                        unsigned long numSamples,
                        float *data,
                        unsigned long samplingRate,
                        const char *unitDescription,
                        int encodingWidth = 0x02,
                        long maxUnscaledValue = 0
                    );
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="int_setData(_unsigned_long_numSamples,_short_*data,_unsigned_long_samplingRate,_const_char_*unitDescription,_float_scale_)$"><hr><p></p><h3>int setData( unsigned long numSamples, short *data, unsigned long samplingRate, const char *unitDescription, float scale );</h3></a>
           Set the data from a series of short
           values.  The data is stored in the
           file based on the setting of the
           encoding value, which defaults to
           short.
           <p>
           Data passed into this routing shoule
           have been divided by the scale factor
           beforehand.  The intention is that
           this will raise the data to relatively
           large integer numbers, so that storage
           in an integer format will not lose
           undue precision.
           <p>
           Note that the sampling rate is set
           in samples per second
<p><pre>
        int <a href="#int_setData(_unsigned_long_numSamples,_float_*data,_unsigned_long_samplingRate,_const_char_*unitDescription,_int_encodingWidth_,_long_maxUnscaledValue_)$">setData</a>(
                        unsigned long numSamples,
                        short *data,
                        unsigned long samplingRate,
                        const char *unitDescription,
                        float scale
                    );
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="int_setData(_unsigned_long_numSamples,_long_*data,_unsigned_long_samplingRate,_const_char_*unitDescription,_float_scale_)$"><hr><p></p><h3>int setData( unsigned long numSamples, long *data, unsigned long samplingRate, const char *unitDescription, float scale );</h3></a>
           Set the data from a series of long
           values.  The data is stored in the
           file based on the setting of the
           encoding value, which defaults to
           short.
           <p>
           Data passed into this routing shoule
           have been divided by the scale factor
           beforehand.  The intention is that
           this will raise the data to relatively
           large integer numbers, so that storage
           in an integer format will not lose
           undue precision.
           <p>
           Note that the sampling rate is set
           in samples per second
<p><pre>
        int <a href="#int_setData(_unsigned_long_numSamples,_float_*data,_unsigned_long_samplingRate,_const_char_*unitDescription,_int_encodingWidth_,_long_maxUnscaledValue_)$">setData</a>(
                        unsigned long numSamples,
                        long *data,
                        unsigned long samplingRate,
                        const char *unitDescription,
                        float scale
                    );
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="enum_Encoding_$"><hr><p></p><h3>enum Encoding ;</h3></a>
           Possible encodings supported by this
           version of the file reader
<p><pre>
        enum Encoding {
                        SHORT   = 0x0002,       // encode data
                                                // using short
                                                // (2-byte) values
                        LONG    = 0x0004        // encode data
                                                // using long
                                                // (4-byte) values
                    } ;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="int_setEncoding(Encoding_encoding)$"><hr><p></p><h3>int setEncoding(Encoding encoding);</h3></a>
           Set the encoding of the data.  The
           default is SHORT
<p><pre>
        int <a href="#int_setEncoding(Encoding_encoding)$">setEncoding</a>(Encoding encoding);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="int_getEncodingFlags()_const$"><hr><p></p><h3>int getEncodingFlags() const;</h3></a>
           Return the flag portion of the
           encoding for this data file.
<p>
           <p>
           Note that in this initial implementation
           of the file specification, there are no
           valid flags.  This will be used in future
           if any changes need to be made to the
           data encoding which will make a future
           file unreadable to this version of the
           parser.  An example of such a change would
           be the implementation of a compression
           scheme, which is currently not in the
           specification.
<p><pre>
        int <a href="#int_getEncodingFlags()_const$">getEncodingFlags</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="int_getEncodingWidth()_const$"><hr><p></p><h3>int getEncodingWidth() const;</h3></a>
           Return the width of the encoding of
           the data in the file.
<p>
           <p>
           Currently, the only two legal widths
           are 2 and 4 bytes.
<p><pre>
        int <a href="#int_getEncodingWidth()_const$">getEncodingWidth</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="short_*getDataAsShort(_unsigned_long_*numSamples,_unsigned_long_*samplingRate,_float_*scale_)$"><hr><p></p><h3>short *getDataAsShort( unsigned long *numSamples, unsigned long *samplingRate, float *scale );</h3></a>
           Return a pointer to the data in
           <b>short</b> format.
           <p>
           In order to convert the data
           back into the format described by
           the unit description, the user is
           expected to multiply the values
           returned here by the value in
           the <b>scale</b> parameter
           <p>
           Note that in order to provide the
           data, the class may have to allocate
           a new buffer and convert the values.
           <p>
           See also <a href="#long_*getDataAsLong(_unsigned_long_*numSamples,_unsigned_long_*samplingRate,_float_*scale_)$">getDataAsLong</a>(), and <a href="#int_getEncodingWidth()_const$">getEncodingWidth</a>()
<p><pre>
        short *<a href="#short_*getDataAsShort(_unsigned_long_*numSamples,_unsigned_long_*samplingRate,_float_*scale_)$">getDataAsShort</a>(
                        unsigned long *numSamples,
                        unsigned long *samplingRate,
                        float *scale
                    );
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="long_*getDataAsLong(_unsigned_long_*numSamples,_unsigned_long_*samplingRate,_float_*scale_)$"><hr><p></p><h3>long *getDataAsLong( unsigned long *numSamples, unsigned long *samplingRate, float *scale );</h3></a>
           Return a pointer to the data in
           <b>long</b> format.
           <p>
           In order to convert the data
           back into the format described by
           the unit description, the user is
           expected to multiply the values
           returned here by the value in
           the <b>scale</b> parameter.
           <p>
           Note that in order to provide the
           data, the class may have to allocate
           a new buffer and convert the values.
           For this reason, this function may
           return failure if the 32-bit data values
           cannot successfully be trimmed into
           16-bit values without overflow.
<p>
           <p>
           See also <a href="#short_*getDataAsShort(_unsigned_long_*numSamples,_unsigned_long_*samplingRate,_float_*scale_)$">getDataAsShort</a>(), and <a href="#int_getEncodingWidth()_const$">getEncodingWidth</a>()
<p><pre>
        long *<a href="#long_*getDataAsLong(_unsigned_long_*numSamples,_unsigned_long_*samplingRate,_float_*scale_)$">getDataAsLong</a>(
                        unsigned long *numSamples,
                        unsigned long *samplingRate,
                        float *scale
                    );
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="const_char_*getUnitDescription()_const$"><hr><p></p><h3>const char *getUnitDescription() const;</h3></a>
           Get the description of the units the
           data was encoded with
<p><pre>
        const char *<a href="#const_char_*getUnitDescription()_const$">getUnitDescription</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="void_setChannelDescription(const_char_*newDescription)$"><hr><p></p><h3>void setChannelDescription(const char *newDescription);</h3></a>
           Set the (optional) text field describing
           the channel settings
<p><pre>
        void <a href="#void_setChannelDescription(const_char_*newDescription)$">setChannelDescription</a>(const char *newDescription);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="const_char_*getChannelDescription()_const$"><hr><p></p><h3>const char *getChannelDescription() const;</h3></a>
           Return the text field describing the
           channel settings.  This is a pointer
           to an internally managed buffer.  Do
           not free() this pointer.
<p><pre>
        const char *<a href="#const_char_*getChannelDescription()_const$">getChannelDescription</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="void_setChannelNumber(unsigned_char_channelNumber)$"><hr><p></p><h3>void setChannelNumber(unsigned char channelNumber);</h3></a>
           Set the channel id number
<p><pre>
        void <a href="#void_setChannelNumber(unsigned_char_channelNumber)$">setChannelNumber</a>(unsigned char channelNumber);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="unsigned_char_getChannelNumber()_const$"><hr><p></p><h3>unsigned char getChannelNumber() const;</h3></a>
           Return the channel id number
<p><pre>
        unsigned char <a href="#unsigned_char_getChannelNumber()_const$">getChannelNumber</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="void_setHighPassCutoff(unsigned_long_frequency)$"><hr><p></p><h3>void setHighPassCutoff(unsigned long frequency);</h3></a>
           Record the frequency used for high-pass filtering
           in µHz
<p><pre>
        void <a href="#void_setHighPassCutoff(unsigned_long_frequency)$">setHighPassCutoff</a>(unsigned long frequency);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="unsigned_long_getHighPassCutoff()_const$"><hr><p></p><h3>unsigned long getHighPassCutoff() const;</h3></a>
           Return the frequency used for high-pass filtering,
           in µHz
<p><pre>
        unsigned long <a href="#unsigned_long_getHighPassCutoff()_const$">getHighPassCutoff</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="void_setLowPassCutoff(unsigned_long_frequency)$"><hr><p></p><h3>void setLowPassCutoff(unsigned long frequency);</h3></a>
           Record the frequency used for low-pass filtering
           in µHz
<p><pre>
        void <a href="#void_setLowPassCutoff(unsigned_long_frequency)$">setLowPassCutoff</a>(unsigned long frequency);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="unsigned_long_getLowPassCutoff()_const$"><hr><p></p><h3>unsigned long getLowPassCutoff() const;</h3></a>
           Return the frequency used for low-pass filtering
           in µHz
<p><pre>
        unsigned long <a href="#unsigned_long_getLowPassCutoff()_const$">getLowPassCutoff</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="void_setElapsedTime(unsigned_long_newTime)$"><hr><p></p><h3>void setElapsedTime(unsigned long newTime);</h3></a>
           Set the total time elapsed for this channel
<p><pre>
        void <a href="#void_setElapsedTime(unsigned_long_newTime)$">setElapsedTime</a>(unsigned long newTime);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="unsigned_long_getElapsedTime()_const$"><hr><p></p><h3>unsigned long getElapsedTime() const;</h3></a>
           Get the total time elapsed for this channel
<p><pre>
        unsigned long <a href="#unsigned_long_getElapsedTime()_const$">getElapsedTime</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="unsigned_long_getNumberOfSamples()_const$"><hr><p></p><h3>unsigned long getNumberOfSamples() const;</h3></a>
           Get the number of samples in this channel
<p><pre>
        unsigned long <a href="#unsigned_long_getNumberOfSamples()_const$">getNumberOfSamples</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="unsigned_long_getSampleRate()_const$"><hr><p></p><h3>unsigned long getSampleRate() const;</h3></a>
           Get the sample Rate in samples per second
<p><pre>
        unsigned long <a href="#unsigned_long_getSampleRate()_const$">getSampleRate</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="float_getScaleFactor()_const$"><hr><p></p><h3>float getScaleFactor() const;</h3></a>
           Get the Scale factor
<p><pre>
        float <a href="#float_getScaleFactor()_const$">getScaleFactor</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="void_setEvokedResponseOnsetPos(short_onset)$"><hr><p></p><h3>void setEvokedResponseOnsetPos(short onset);</h3></a>
           Set onset position in evoked response
<p><pre>
        void <a href="#void_setEvokedResponseOnsetPos(short_onset)$">setEvokedResponseOnsetPos</a>(short onset);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="short_getEvokedResponseOnsetPos()_const$"><hr><p></p><h3>short getEvokedResponseOnsetPos() const;</h3></a>
           Get evoked response onset position
<p><pre>
        short <a href="#short_getEvokedResponseOnsetPos()_const$">getEvokedResponseOnsetPos</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="void_setEvokedResponsePeakOnsetPos(short_peakOnset)$"><hr><p></p><h3>void setEvokedResponsePeakOnsetPos(short peakOnset);</h3></a>
           set evoked resopnse peak onset position
<p><pre>
        void <a href="#void_setEvokedResponsePeakOnsetPos(short_peakOnset)$">setEvokedResponsePeakOnsetPos</a>(short peakOnset);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="short_getEvokedResponsePeakOnsetPos()_const$"><hr><p></p><h3>short getEvokedResponsePeakOnsetPos() const;</h3></a>
           get evoked response peak onset position
<p><pre>
        short <a href="#short_getEvokedResponsePeakOnsetPos()_const$">getEvokedResponsePeakOnsetPos</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="void_setEvokedResponseNegativePeakPos(short_NegativePeak)$"><hr><p></p><h3>void setEvokedResponseNegativePeakPos(short NegativePeak);</h3></a>
           Set negative peak position in evoked response
<p><pre>
        void <a href="#void_setEvokedResponseNegativePeakPos(short_NegativePeak)$">setEvokedResponseNegativePeakPos</a>(short NegativePeak);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="short_getEvokedResponseNegativePeakPos()_const$"><hr><p></p><h3>short getEvokedResponseNegativePeakPos() const;</h3></a>
           Get evoked response negative peak position
<p><pre>
        short <a href="#short_getEvokedResponseNegativePeakPos()_const$">getEvokedResponseNegativePeakPos</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="void_setEvokedResponsePeakEndPos(short_peakEnd)$"><hr><p></p><h3>void setEvokedResponsePeakEndPos(short peakEnd);</h3></a>
           Set evoked reponse negative peak end position
<p><pre>
        void <a href="#void_setEvokedResponsePeakEndPos(short_peakEnd)$">setEvokedResponsePeakEndPos</a>(short peakEnd);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="short_getEvokedResponsePeakEndPos()_const$"><hr><p></p><h3>short getEvokedResponsePeakEndPos() const;</h3></a>
           Get evoked reponse negative peak end position
<p><pre>
        short <a href="#short_getEvokedResponsePeakEndPos()_const$">getEvokedResponsePeakEndPos</a>() const;      
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="void_setEvokedResponsePositivePeakPos(short_posPeak)$"><hr><p></p><h3>void setEvokedResponsePositivePeakPos(short posPeak);</h3></a>
           Set positive peak position in evoked response
<p><pre>
        void <a href="#void_setEvokedResponsePositivePeakPos(short_posPeak)$">setEvokedResponsePositivePeakPos</a>(short posPeak);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="short_getEvokedResponsePositivePeakPos()_const$"><hr><p></p><h3>short getEvokedResponsePositivePeakPos() const;</h3></a>
           Get evoked response positive peak position
<p><pre>
        short <a href="#short_getEvokedResponsePositivePeakPos()_const$">getEvokedResponsePositivePeakPos</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="void_setEvokedResponseEndPos(short_End)$"><hr><p></p><h3>void setEvokedResponseEndPos(short End);</h3></a>
           Set end position in evoked response
<p><pre>
        void <a href="#void_setEvokedResponseEndPos(short_End)$">setEvokedResponseEndPos</a>(short End);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="short_getEvokedResponseEndPos()_const$"><hr><p></p><h3>short getEvokedResponseEndPos() const;</h3></a>
           Get evoked response end position
<p><pre>
        short <a href="#short_getEvokedResponseEndPos()_const$">getEvokedResponseEndPos</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="void_setEvokedResponsePeakToPeakAmplitude(float_peakToPeakAmplitude)$"><hr><p></p><h3>void setEvokedResponsePeakToPeakAmplitude(float peakToPeakAmplitude);</h3></a>
           Set evoked resopnse peak to peak amplitude
<p><pre>
        void <a href="#void_setEvokedResponsePeakToPeakAmplitude(float_peakToPeakAmplitude)$">setEvokedResponsePeakToPeakAmplitude</a>(float peakToPeakAmplitude);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="float_getEvokedResponsePeakToPeakAmplitude()_const$"><hr><p></p><h3>float getEvokedResponsePeakToPeakAmplitude() const;</h3></a>
           Get evoked response peak to peak amplitude
<p><pre>
        float <a href="#float_getEvokedResponsePeakToPeakAmplitude()_const$">getEvokedResponsePeakToPeakAmplitude</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="void_setEvokedResponseNegativePeakAmplitude(float_negativePeakAmplitude)$"><hr><p></p><h3>void setEvokedResponseNegativePeakAmplitude(float negativePeakAmplitude);</h3></a>
           Set evoked response negative peak amplitude
<p><pre>
        void <a href="#void_setEvokedResponseNegativePeakAmplitude(float_negativePeakAmplitude)$">setEvokedResponseNegativePeakAmplitude</a>(float negativePeakAmplitude);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="float_getEvokedResponseNegativePeakAmplitude()_const$"><hr><p></p><h3>float getEvokedResponseNegativePeakAmplitude() const;</h3></a>
           Get evoked response negative peak amplitude
<p><pre>
        float <a href="#float_getEvokedResponseNegativePeakAmplitude()_const$">getEvokedResponseNegativePeakAmplitude</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="void_setEvokedResponseDuration(float_duration)$"><hr><p></p><h3>void setEvokedResponseDuration(float duration);</h3></a>
           set evoked response duration
<p><pre>
        void <a href="#void_setEvokedResponseDuration(float_duration)$">setEvokedResponseDuration</a>(float duration);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="float_getEvokedResponseDuration()_const$"><hr><p></p><h3>float getEvokedResponseDuration() const;</h3></a>
           get evoked response duration 
<p><pre>
        float <a href="#float_getEvokedResponseDuration()_const$">getEvokedResponseDuration</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="void_setEvokedResponseNegativePeakDuration(float_negativePeakDuration)$"><hr><p></p><h3>void setEvokedResponseNegativePeakDuration(float negativePeakDuration);</h3></a>
           set evoked response negative peak duration
<p><pre>
        void <a href="#void_setEvokedResponseNegativePeakDuration(float_negativePeakDuration)$">setEvokedResponseNegativePeakDuration</a>(float negativePeakDuration);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="float_getEvokedResponseNegativePeakDuration()_const$"><hr><p></p><h3>float getEvokedResponseNegativePeakDuration() const;</h3></a>
           get evoked response negative peak duration
<p><pre>
        float <a href="#float_getEvokedResponseNegativePeakDuration()_const$">getEvokedResponseNegativePeakDuration</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="void_setEvokedResponseNegativePeakArea(float_negativePeakArea)$"><hr><p></p><h3>void setEvokedResponseNegativePeakArea(float negativePeakArea);</h3></a>
           Set evoked response negative to peak area
<p><pre>
	void <a href="#void_setEvokedResponseNegativePeakArea(float_negativePeakArea)$">setEvokedResponseNegativePeakArea</a>(float negativePeakArea);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="float_getEvokedResponseNegativePeakArea()_const$"><hr><p></p><h3>float getEvokedResponseNegativePeakArea() const;</h3></a>
	   Get evoked response negative peak area
<p><pre>
        float <a href="#float_getEvokedResponseNegativePeakArea()_const$">getEvokedResponseNegativePeakArea</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="void_setEvokedResponseArea(float_area)$"><hr><p></p><h3>void setEvokedResponseArea(float area);</h3></a>
           set evoked response area
<p><pre>
        void <a href="#void_setEvokedResponseArea(float_area)$">setEvokedResponseArea</a>(float area);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="float_getEvokedResponseArea()_const$"><hr><p></p><h3>float getEvokedResponseArea() const;</h3></a>
           get evoked response area
<p><pre>
        float <a href="#float_getEvokedResponseArea()_const$">getEvokedResponseArea</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="void_setEvokedResponseValidity(bool_Valid)$"><hr><p></p><h3>void setEvokedResponseValidity(bool Valid);</h3></a>
           Set evoked resopne validity flag
	   This flag is used to indicate if an 
	   evoked response is to be included in a study or not
<p><pre>
        void <a href="#void_setEvokedResponseValidity(bool_Valid)$">setEvokedResponseValidity</a>(bool Valid);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="bool_getEvokedResponseValidity()_const$"><hr><p></p><h3>bool getEvokedResponseValidity() const;</h3></a>
           Get evoked resopne validity flag
<p><pre>
        bool <a href="#bool_getEvokedResponseValidity()_const$">getEvokedResponseValidity</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="void_setNumberOfSmupsInAvg(int_NumSmups)$"><hr><p></p><h3>void setNumberOfSmupsInAvg(int NumSmups);</h3></a>
	   save the number of surface mups in
	   the mSMUP
	   This information is used in MPS when calculating the mSMUP
<p><pre>
        void <a href="#void_setNumberOfSmupsInAvg(int_NumSmups)$">setNumberOfSmupsInAvg</a>(int NumSmups);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="int_getNumberOfSmupsInAvg()_const$"><hr><p></p><h3>int getNumberOfSmupsInAvg() const;</h3></a>
	   read the number of surface mups in
	   the mSMUP
<p><pre>
        int <a href="#int_getNumberOfSmupsInAvg()_const$">getNumberOfSmupsInAvg</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="void_dump(FILE_*fp)$"><hr><p></p><h3>void dump(FILE *fp);</h3></a>
           Dump all the header info to the given
           file pointer.
<p><pre>
        void <a href="#void_dump(FILE_*fp)$">dump</a>(FILE *fp);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> DQEmgChannelData </i> <p>
<a name="flat"><hr><p></p></a>
<h2>All Members</h2>
<dl>
<dt><strong>public:</strong>
<dd>int <a href="DQEmgChannelData.html#int_setData(_unsigned_long_numSamples,_float_*data,_unsigned_long_samplingRate,_const_char_*unitDescription,_int_encodingWidth_,_long_maxUnscaledValue_)$"><font color=green>setData</font></a>( unsigned long numSamples, float *data, unsigned long samplingRate, const char *unitDescription, int encodingWidth , long maxUnscaledValue );
<dd>int <a href="DQEmgChannelData.html#int_setData(_unsigned_long_numSamples,_short_*data,_unsigned_long_samplingRate,_const_char_*unitDescription,_float_scale_)$"><font color=green>setData</font></a>( unsigned long numSamples, short *data, unsigned long samplingRate, const char *unitDescription, float scale );
<dd>int <a href="DQEmgChannelData.html#int_setData(_unsigned_long_numSamples,_long_*data,_unsigned_long_samplingRate,_const_char_*unitDescription,_float_scale_)$"><font color=green>setData</font></a>( unsigned long numSamples, long *data, unsigned long samplingRate, const char *unitDescription, float scale );
<dd>enum <a href="DQEmgChannelData.html#enum_Encoding_$"><font color=green>Encoding</font></a> ;
<dd>int <a href="DQEmgChannelData.html#int_setEncoding(Encoding_encoding)$"><font color=green>setEncoding</font></a>(Encoding encoding);
<dd>int <a href="DQEmgChannelData.html#int_getEncodingFlags()_const$"><font color=green>getEncodingFlags</font></a>() const;
<dd>int <a href="DQEmgChannelData.html#int_getEncodingWidth()_const$"><font color=green>getEncodingWidth</font></a>() const;
<dd>short *<a href="DQEmgChannelData.html#short_*getDataAsShort(_unsigned_long_*numSamples,_unsigned_long_*samplingRate,_float_*scale_)$"><font color=green>getDataAsShort</font></a>( unsigned long *numSamples, unsigned long *samplingRate, float *scale );
<dd>long *<a href="DQEmgChannelData.html#long_*getDataAsLong(_unsigned_long_*numSamples,_unsigned_long_*samplingRate,_float_*scale_)$"><font color=green>getDataAsLong</font></a>( unsigned long *numSamples, unsigned long *samplingRate, float *scale );
<dd>const char *<a href="DQEmgChannelData.html#const_char_*getUnitDescription()_const$"><font color=green>getUnitDescription</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setChannelDescription(const_char_*newDescription)$"><font color=green>setChannelDescription</font></a>(const char *newDescription);
<dd>const char *<a href="DQEmgChannelData.html#const_char_*getChannelDescription()_const$"><font color=green>getChannelDescription</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setChannelNumber(unsigned_char_channelNumber)$"><font color=green>setChannelNumber</font></a>(unsigned char channelNumber);
<dd>unsigned char <a href="DQEmgChannelData.html#unsigned_char_getChannelNumber()_const$"><font color=green>getChannelNumber</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setHighPassCutoff(unsigned_long_frequency)$"><font color=green>setHighPassCutoff</font></a>(unsigned long frequency);
<dd>unsigned long <a href="DQEmgChannelData.html#unsigned_long_getHighPassCutoff()_const$"><font color=green>getHighPassCutoff</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setLowPassCutoff(unsigned_long_frequency)$"><font color=green>setLowPassCutoff</font></a>(unsigned long frequency);
<dd>unsigned long <a href="DQEmgChannelData.html#unsigned_long_getLowPassCutoff()_const$"><font color=green>getLowPassCutoff</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setElapsedTime(unsigned_long_newTime)$"><font color=green>setElapsedTime</font></a>(unsigned long newTime);
<dd>unsigned long <a href="DQEmgChannelData.html#unsigned_long_getElapsedTime()_const$"><font color=green>getElapsedTime</font></a>() const;
<dd>unsigned long <a href="DQEmgChannelData.html#unsigned_long_getNumberOfSamples()_const$"><font color=green>getNumberOfSamples</font></a>() const;
<dd>unsigned long <a href="DQEmgChannelData.html#unsigned_long_getSampleRate()_const$"><font color=green>getSampleRate</font></a>() const;
<dd>float <a href="DQEmgChannelData.html#float_getScaleFactor()_const$"><font color=green>getScaleFactor</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponseOnsetPos(short_onset)$"><font color=green>setEvokedResponseOnsetPos</font></a>(short onset);
<dd>short <a href="DQEmgChannelData.html#short_getEvokedResponseOnsetPos()_const$"><font color=green>getEvokedResponseOnsetPos</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponsePeakOnsetPos(short_peakOnset)$"><font color=green>setEvokedResponsePeakOnsetPos</font></a>(short peakOnset);
<dd>short <a href="DQEmgChannelData.html#short_getEvokedResponsePeakOnsetPos()_const$"><font color=green>getEvokedResponsePeakOnsetPos</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponseNegativePeakPos(short_NegativePeak)$"><font color=green>setEvokedResponseNegativePeakPos</font></a>(short NegativePeak);
<dd>short <a href="DQEmgChannelData.html#short_getEvokedResponseNegativePeakPos()_const$"><font color=green>getEvokedResponseNegativePeakPos</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponsePeakEndPos(short_peakEnd)$"><font color=green>setEvokedResponsePeakEndPos</font></a>(short peakEnd);
<dd>short <a href="DQEmgChannelData.html#short_getEvokedResponsePeakEndPos()_const$"><font color=green>getEvokedResponsePeakEndPos</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponsePositivePeakPos(short_posPeak)$"><font color=green>setEvokedResponsePositivePeakPos</font></a>(short posPeak);
<dd>short <a href="DQEmgChannelData.html#short_getEvokedResponsePositivePeakPos()_const$"><font color=green>getEvokedResponsePositivePeakPos</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponseEndPos(short_End)$"><font color=green>setEvokedResponseEndPos</font></a>(short End);
<dd>short <a href="DQEmgChannelData.html#short_getEvokedResponseEndPos()_const$"><font color=green>getEvokedResponseEndPos</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponsePeakToPeakAmplitude(float_peakToPeakAmplitude)$"><font color=green>setEvokedResponsePeakToPeakAmplitude</font></a>(float peakToPeakAmplitude);
<dd>float <a href="DQEmgChannelData.html#float_getEvokedResponsePeakToPeakAmplitude()_const$"><font color=green>getEvokedResponsePeakToPeakAmplitude</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponseNegativePeakAmplitude(float_negativePeakAmplitude)$"><font color=green>setEvokedResponseNegativePeakAmplitude</font></a>(float negativePeakAmplitude);
<dd>float <a href="DQEmgChannelData.html#float_getEvokedResponseNegativePeakAmplitude()_const$"><font color=green>getEvokedResponseNegativePeakAmplitude</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponseDuration(float_duration)$"><font color=green>setEvokedResponseDuration</font></a>(float duration);
<dd>float <a href="DQEmgChannelData.html#float_getEvokedResponseDuration()_const$"><font color=green>getEvokedResponseDuration</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponseNegativePeakDuration(float_negativePeakDuration)$"><font color=green>setEvokedResponseNegativePeakDuration</font></a>(float negativePeakDuration);
<dd>float <a href="DQEmgChannelData.html#float_getEvokedResponseNegativePeakDuration()_const$"><font color=green>getEvokedResponseNegativePeakDuration</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponseNegativePeakArea(float_negativePeakArea)$"><font color=green>setEvokedResponseNegativePeakArea</font></a>(float negativePeakArea);
<dd>float <a href="DQEmgChannelData.html#float_getEvokedResponseNegativePeakArea()_const$"><font color=green>getEvokedResponseNegativePeakArea</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponseArea(float_area)$"><font color=green>setEvokedResponseArea</font></a>(float area);
<dd>float <a href="DQEmgChannelData.html#float_getEvokedResponseArea()_const$"><font color=green>getEvokedResponseArea</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setEvokedResponseValidity(bool_Valid)$"><font color=green>setEvokedResponseValidity</font></a>(bool Valid);
<dd>bool <a href="DQEmgChannelData.html#bool_getEvokedResponseValidity()_const$"><font color=green>getEvokedResponseValidity</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_setNumberOfSmupsInAvg(int_NumSmups)$"><font color=green>setNumberOfSmupsInAvg</font></a>(int NumSmups);
<dd>int <a href="DQEmgChannelData.html#int_getNumberOfSmupsInAvg()_const$"><font color=green>getNumberOfSmupsInAvg</font></a>() const;
<dd>void <a href="DQEmgChannelData.html#void_dump(FILE_*fp)$"><font color=green>dump</font></a>(FILE *fp);
<dt><strong>protected:</strong>
</dl>
<p>Back to the <a href="#topofdoc">top</a> of  DQEmgChannelData<p>
<a name="parents"><hr><p></p></a>
<h2>Ancestors</h2>
Class does not inherit from any other class.<p>
<p>Back to the <a href="#topofdoc">top</a> of  DQEmgChannelData<p>
<a name="children"><hr><p></p></a>
<h2>Descendants</h2>
Class is not inherited by any others.<p>
<p>Back to the <a href="#topofdoc">top</a> of  DQEmgChannelData<p>
<hr><p></p>
Generated from source by the <i><a href="http://www.stratasys.com/software/cocoon/index.htm">Cocoon</a></i> utilities on Thu Jan 15 07:27:46 2004
.<p>
<address>Report <a href="mailto:jkotula@vitalimages.com">problems</a> to jkotula@vitalimages.com</address>
</body></html>
